import "./chunk-IN47U6CF.js";

// node_modules/.pnpm/vue3-infinite-scroll-better@2.2.0/node_modules/vue3-infinite-scroll-better/lib/uitls.js
var throttle = function(fn, delay, context) {
  let now = 0;
  let lastExec = 0;
  let timer = null;
  const execute = () => {
    fn(context);
    lastExec = now;
  };
  return () => {
    now = Date.now();
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    if (lastExec) {
      const diff = delay - (now - lastExec);
      if (diff < 0) {
        execute();
      } else {
        timer = setTimeout(function() {
          execute();
        }, diff);
      }
    } else {
      execute();
    }
  };
};

// node_modules/.pnpm/vue3-infinite-scroll-better@2.2.0/node_modules/vue3-infinite-scroll-better/lib/infinite-scroll.js
var ctx = "vue3@InfiniteScroll";
var getScrollTop = function(element) {
  if (element === window) {
    return Math.max(window.pageYOffset || 0, document.documentElement.scrollTop);
  }
  return element.scrollTop;
};
var getComputedStyle = document.defaultView.getComputedStyle;
var getScrollEventTarget = function(element) {
  let currentNode = element;
  while (currentNode && currentNode.tagName !== "HTML" && currentNode.tagName !== "BODY" && currentNode.nodeType === 1) {
    const overflowY = getComputedStyle(currentNode).overflowY;
    if (overflowY === "scroll" || overflowY === "auto") {
      return currentNode;
    }
    currentNode = currentNode.parentNode;
  }
  return window;
};
var getVisibleHeight = function(element) {
  if (element === window) {
    return document.documentElement.clientHeight;
  }
  return element.clientHeight;
};
var getElementTop = function(element) {
  if (element === window) {
    return getScrollTop(window);
  }
  return element.getBoundingClientRect().top + getScrollTop(window);
};
var isAttached = function(element) {
  let currentNode = element.parentNode;
  while (currentNode) {
    if (currentNode.tagName === "HTML") {
      return true;
    }
    if (currentNode.nodeType === 11) {
      return false;
    }
    currentNode = currentNode.parentNode;
  }
  return false;
};
var doBind = function doBind2(context) {
  if (context.binded)
    return;
  context.binded = true;
  const self = context;
  const element = self.el;
  const throttleDelayExpr = element.getAttribute("infinite-scroll-throttle-delay");
  let throttleDelay = 200;
  if (throttleDelayExpr !== null && throttleDelayExpr !== void 0) {
    throttleDelay = Number(throttleDelayExpr);
    if (isNaN(throttleDelay) || throttleDelay < 0) {
      throttleDelay = 200;
    }
  }
  self.throttleDelay = throttleDelay;
  self.scrollEventTarget = getScrollEventTarget(element);
  self.scrollListener = throttle(doCheck, self.throttleDelay, self);
  self.scrollEventTarget.addEventListener("scroll", self.scrollListener);
  const disabledExpr = element.getAttribute("infinite-scroll-disabled");
  let disabled = false;
  const watchDisabledExpr = element.getAttribute("infinite-scroll-watch-disabled");
  if (disabledExpr !== null && disabledExpr !== void 0) {
    context.vm.$watch(watchDisabledExpr, function(value) {
      self.disabled = value;
      if (!value && self.immediateCheck) {
        doCheck(self);
      }
    });
    disabled = disabledExpr === "true";
  }
  self.disabled = disabled;
  const distanceExpr = element.getAttribute("infinite-scroll-distance");
  let distance = 0;
  if (distanceExpr !== null && distanceExpr !== void 0) {
    distance = Number(distanceExpr);
    if (isNaN(distance)) {
      distance = 0;
    }
  }
  self.distance = distance;
  const immediateCheckExpr = element.getAttribute("infinite-scroll-immediate-check");
  let immediateCheck = true;
  if (immediateCheckExpr !== null && immediateCheckExpr !== void 0) {
    immediateCheck = Boolean(immediateCheckExpr);
  }
  self.immediateCheck = immediateCheck;
  if (immediateCheck) {
    doCheck(self);
  }
};
var doCheck = function doCheck2(context, force) {
  const scrollEventTarget = context.scrollEventTarget;
  const element = context.el;
  const distance = context.distance;
  if (force !== true && context.disabled)
    return;
  const viewportScrollTop = getScrollTop(scrollEventTarget);
  const viewportBottom = viewportScrollTop + getVisibleHeight(scrollEventTarget);
  let shouldTrigger = false;
  if (scrollEventTarget === element) {
    shouldTrigger = scrollEventTarget.scrollHeight - viewportBottom <= distance;
  } else {
    const elementBottom = getElementTop(element) - getElementTop(scrollEventTarget) + element.offsetHeight + viewportScrollTop;
    shouldTrigger = viewportBottom + distance >= elementBottom;
  }
  if (shouldTrigger && context.expression) {
    context.expression();
  }
};
var InfiniteScroll = {
  created: function bind(el, binding, vnode) {
    el[ctx] = {
      el,
      vm: binding.instance,
      expression: binding.value
    };
    el[ctx].vm.$nextTick(function() {
      if (isAttached(el)) {
        doBind(el[ctx]);
      }
      el[ctx].bindTryCount = 0;
      const tryBind = function tryBind2() {
        if (el[ctx].bindTryCount > 10)
          return;
        el[ctx].bindTryCount++;
        if (isAttached(el)) {
          doBind(el[ctx]);
        } else {
          setTimeout(tryBind2, 50);
        }
      };
      tryBind();
    });
  },
  unmounted: function unbind(el) {
    if (el && el[ctx] && el[ctx].scrollEventTarget)
      el[ctx].scrollEventTarget.removeEventListener("scroll", el[ctx].scrollListener);
  }
};
var install = function install2(Vue) {
  Vue.directive("InfiniteScroll", InfiniteScroll);
};
InfiniteScroll.install = install;
var infinite_scroll_default = InfiniteScroll;

// node_modules/.pnpm/vue3-infinite-scroll-better@2.2.0/node_modules/vue3-infinite-scroll-better/index.js
var vue3_infinite_scroll_better_default = infinite_scroll_default;
export {
  vue3_infinite_scroll_better_default as default
};
//# sourceMappingURL=vue3-infinite-scroll-better.js.map
